// This fuzz test was generated by GPT-4.
#![no_main]
use libfuzzer_sys::fuzz_target;
use zopfli::ffi::{ZopfliLZ77Store, ZopfliOptions, ZopfliBlockState, ZopfliHash};
use libfuzzer_sys::arbitrary::{self, Arbitrary, Unstructured};
use std::mem::ManuallyDrop;

use std::os::raw::{c_int, c_uchar};

use zopfli::deflate::{AddLZ77BlockAutoType};

#[derive(Debug)]
struct FuzzInput {
    options: ZopfliOptions,
    is_final: bool,
    data: Vec<u8>,
    lstart: u16,
    lend: u16,
}

impl<'a> Arbitrary<'a> for FuzzInput {
    fn arbitrary(u: &mut Unstructured<'a>) -> arbitrary::Result<Self> {
        let options = ZopfliOptions {
            verbose: u.int_in_range(0..=1)?,
            verbose_more: u.int_in_range(0..=1)?,
            numiterations: u.int_in_range(1..=15)?,
            blocksplitting: u.int_in_range(0..=1)?,
            blocksplittinglast: u.int_in_range(0..=1)?,
            blocksplittingmax: u.int_in_range(0..=10)?,
        };
        Ok(FuzzInput {
            options,
            is_final: u.arbitrary()?,
            data: u.arbitrary()?,
            lstart: u.arbitrary()?,
            lend: u.arbitrary()?,
        })
    }
}

fn initialize_out_buffer() -> (*mut *mut c_uchar, *mut usize, ManuallyDrop<Vec<u8>>) {
    let initial_size = 65536; // A large fixed size
    let mut buffer = ManuallyDrop::new(vec![0u8; initial_size]);
    let outsize = Box::into_raw(Box::new(initial_size));
    let out = Box::into_raw(Box::new(buffer.as_mut_ptr()));
    (out, outsize, buffer)
}

fn get_buffer_data(out: *mut *mut c_uchar, outsize: *mut usize, bp: u8) -> (Vec<u8>, u8) {
    unsafe {
        let buffer_ptr = *out;
        let size = *outsize;
        let slice = std::slice::from_raw_parts(buffer_ptr, size);
        (slice.to_vec(), bp)
    }
}

fuzz_target!(|input: FuzzInput| {
    let mut options = input.options;
    options.blocksplitting = 0; // To avoid recursive calls and simplify test
    let final_block = input.is_final as c_int;
    let data = &input.data;
    let data_size = data.len();

    if data_size == 0 {
        return;
    }

    let mut lz77_c: ZopfliLZ77Store = unsafe { std::mem::zeroed() };
    let mut lz77_rust: ZopfliLZ77Store = unsafe { std::mem::zeroed() };

    unsafe {
        zopfli::ffi::ZopfliInitLZ77Store(data.as_ptr(), &mut lz77_c);
        zopfli::ffi::ZopfliInitLZ77Store(data.as_ptr(), &mut lz77_rust);
    }

    let mut s_c: ZopfliBlockState = unsafe { std::mem::zeroed() };
    let mut s_rust: ZopfliBlockState = unsafe { std::mem::zeroed() };
    let mut h_c: ZopfliHash = unsafe { std::mem::zeroed() };
    let mut h_rust: ZopfliHash = unsafe { std::mem::zeroed() };

    unsafe {
        zopfli::ffi::ZopfliInitBlockState(&options, 0, data_size, 0, &mut s_c);
        zopfli::ffi::ZopfliInitBlockState(&options, 0, data_size, 0, &mut s_rust);
        zopfli::ffi::ZopfliAllocHash(32768, &mut h_c);
        zopfli::ffi::ZopfliAllocHash(32768, &mut h_rust);
        zopfli::ffi::ZopfliLZ77Greedy(&mut s_c, data.as_ptr(), 0, data_size, &mut lz77_c, &mut h_c);
        zopfli::ffi::ZopfliLZ77Greedy(&mut s_rust, data.as_ptr(), 0, data_size, &mut lz77_rust, &mut h_rust);
    }
    
    let size = lz77_c.size;
    let lstart = if size == 0 { 0 } else { input.lstart as usize % size };
    let mut lend = if size == 0 { 0 } else { input.lend as usize % size };
    if lstart > lend {
        lend = lstart;
    }

    let (c_out, c_outsize, _c_buffer) = initialize_out_buffer();
    let (rust_out, rust_outsize, _rust_buffer) = initialize_out_buffer();

    let mut c_bp = 0;
    let mut rust_bp = 0;

    let expected_data_size = unsafe { zopfli::ffi::ZopfliLZ77GetByteRange(&lz77_c, lstart, lend) };

    unsafe {
        zopfli::ffi::AddLZ77BlockAutoType(&options, final_block, &lz77_c, lstart, lend, expected_data_size, &mut c_bp, c_out, c_outsize);
        AddLZ77BlockAutoType(&options, final_block, &lz77_rust, lstart, lend, expected_data_size, &mut rust_bp, rust_out, rust_outsize);
    }
    
    let (c_data, c_bp_final) = get_buffer_data(c_out, c_outsize, c_bp);
    let (rust_data, rust_bp_final) = get_buffer_data(rust_out, rust_outsize, rust_bp);
    
    assert_eq!(c_bp_final, rust_bp_final);
    assert_eq!(c_data, rust_data);
    unsafe {
        assert_eq!(*c_outsize, *rust_outsize);
    }

    unsafe {
        zopfli::ffi::ZopfliCleanLZ77Store(&mut lz77_c);
        zopfli::ffi::ZopfliCleanLZ77Store(&mut lz77_rust);
        zopfli::ffi::ZopfliCleanBlockState(&mut s_c);
        zopfli::ffi::ZopfliCleanBlockState(&mut s_rust);
        zopfli::ffi::ZopfliCleanHash(&mut h_c);
        zopfli::ffi::ZopfliCleanHash(&mut h_rust);
    }
});
