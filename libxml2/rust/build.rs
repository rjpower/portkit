use std::env;
use std::fs;
use std::path::PathBuf;
use std::process::Command;
use std::collections::HashMap;

const C_SOURCE_DIR: &str = "..";
const INCLUDE_DIRS: &[&str] = &[
    "..",                   // For config.h and libxml.h (first so they're found first)
    "../include",           // Main libxml2 headers
    "../include/libxml",    // Public headers  
    // Note: private headers added last to avoid conflicts with system headers
];

// Mapping of module names to their C files
const MODULE_FILES: &[(&str, &[&str])] = &[
    ("xmlstring", &["xmlstring.c"]),
    ("chvalid", &["chvalid.c"]),
    ("dict", &["dict.c"]),
    ("hash", &["hash.c"]),
    ("list", &["list.c"]),
    ("buf", &["buf.c"]),
    ("xmlmemory", &["xmlmemory.c"]),
    ("error", &["error.c"]),
    ("threads", &["threads.c"]),
    ("encoding", &["encoding.c"]),
    ("xmlio", &["xmlIO.c"]),
    ("uri", &["uri.c"]),
    ("entities", &["entities.c"]),
    ("tree", &["tree.c", "timsort.h"]),
    ("xmlsave", &["xmlsave.c"]),
    ("parser-internals", &["parserInternals.c"]),
    ("parser", &["parser.c"]),
    ("sax2", &["SAX2.c"]),
    ("xpath", &["xpath.c"]),
    ("pattern", &["pattern.c"]),
    ("xpointer", &["xpointer.c"]),
    ("valid", &["valid.c"]),
    ("xmlregexp", &["xmlregexp.c"]),
    ("xmlschemas", &["xmlschemas.c"]),
    ("relaxng", &["relaxng.c"]),
    ("schematron", &["schematron.c"]),
    ("htmlparser", &["HTMLparser.c"]),
    ("htmltree", &["HTMLtree.c"]),
    ("xmlreader", &["xmlreader.c"]),
    ("xmlwriter", &["xmlwriter.c"]),
    ("c14n", &["c14n.c"]),
];

// Additional C files not covered by the main modules
const ADDITIONAL_C_FILES: &[&str] = &[
    "catalog.c", "debugXML.c", "globals.c", "nanohttp.c", 
    "xinclude.c", "xlink.c", "xmlmodule.c", "xmlschemastypes.c", "xzlib.c"
];

fn main() {
    println!("cargo:rerun-if-changed=build.rs");
    println!("cargo:rerun-if-env-changed=RUST_MODULES");
    
    // Step 0: Ensure configure has been run and config files exist
    ensure_configure_generated().expect("Failed to run configure");
    
    // Step 1: Determine which modules are implemented in Rust
    let rust_modules = get_rust_modules();
    
    // Step 2: Generate wrapper.h with only C module headers
    generate_wrapper_header(&rust_modules).expect("Failed to generate wrapper.h");
    
    // Step 3: Build C library excluding Rust modules
    build_c_library(&rust_modules).expect("Failed to build C library");
    
    // Step 4: Generate bindings from wrapper.h
    generate_bindings().expect("Failed to generate bindings");
    
    // Step 5: Set up linking
    setup_linking();
}

fn get_rust_modules() -> Vec<String> {
    let mut rust_modules = Vec::new();
    
    // First check environment variable
    if let Ok(modules) = env::var("RUST_MODULES") {
        for module in modules.split(',') {
            let module = module.trim();
            if MODULE_FILES.iter().any(|(name, _)| *name == module) {
                rust_modules.push(module.to_string());
            }
        }
    }
    
    // Also check which features are enabled
    for (module, _) in MODULE_FILES {
        let feature_var = format!("CARGO_FEATURE_RUST_{}", module.to_uppercase().replace('-', "_"));
        if env::var(&feature_var).is_ok() {
            if !rust_modules.contains(&module.to_string()) {
                rust_modules.push(module.to_string());
            }
        }
    }
    
    rust_modules
}

fn ensure_configure_generated() -> Result<(), Box<dyn std::error::Error>> {
    let config_h_path = "../config.h";
    let xmlversion_h_path = "../include/libxml/xmlversion.h";
    let configure_path = "../configure";

    // Check if both config.h and xmlversion.h exist
    let config_exists = std::path::Path::new(config_h_path).exists();
    let xmlversion_exists = std::path::Path::new(xmlversion_h_path).exists();

    if !config_exists || !xmlversion_exists {
        println!("cargo:rerun-if-changed={}", configure_path);
        println!("cargo:rerun-if-changed=../configure.ac");
        println!("cargo:rerun-if-changed=../config.h.in");
        println!("cargo:rerun-if-changed=../include/libxml/xmlversion.h.in");

        println!("Running configure to generate config files...");
        
        // Run configure from the parent directory
        let output = Command::new("./configure")
            .current_dir("..")
            .output()?;

        if !output.status.success() {
            let stderr = String::from_utf8_lossy(&output.stderr);
            eprintln!("Configure failed with error: {}", stderr);
            return Err(format!("Configure script failed: {}", stderr).into());
        }

        // Verify the files were created
        if !std::path::Path::new(config_h_path).exists() {
            return Err("config.h was not generated by configure".into());
        }
        if !std::path::Path::new(xmlversion_h_path).exists() {
            return Err("xmlversion.h was not generated by configure".into());
        }

        println!("Configure completed successfully");
    }

    Ok(())
}

fn generate_wrapper_header(_rust_modules: &[String]) -> Result<(), Box<dyn std::error::Error>> {
    let mut wrapper = String::from("#ifndef LIBXML2_WRAPPER_H\n#define LIBXML2_WRAPPER_H\n\n");
    
    // Include all public libxml2 headers for complete bindgen coverage
    let public_headers = [
        "libxml/xmlexports.h",
        "libxml/xmlversion.h", 
        "libxml/xmlerror.h",
        "libxml/globals.h",
        "libxml/xmlmemory.h",
        "libxml/xmlstring.h",
        "libxml/dict.h",
        "libxml/hash.h",
        "libxml/list.h",
        "libxml/threads.h",
        "libxml/chvalid.h",
        "libxml/encoding.h",
        "libxml/xmlIO.h",
        "libxml/uri.h",
        "libxml/entities.h",
        "libxml/tree.h",
        "libxml/xmlsave.h",
        "libxml/parserInternals.h", 
        "libxml/parser.h",
        "libxml/SAX.h",
        "libxml/SAX2.h",
        "libxml/xpath.h",
        "libxml/xpathInternals.h",
        "libxml/pattern.h",
        "libxml/xpointer.h",
        "libxml/valid.h",
        "libxml/xmlregexp.h",
        "libxml/xmlschemas.h",
        "libxml/xmlschemastypes.h",
        "libxml/schemasInternals.h",
        "libxml/relaxng.h",
        "libxml/schematron.h",
        "libxml/HTMLparser.h",
        "libxml/HTMLtree.h",
        "libxml/xmlreader.h",
        "libxml/xmlwriter.h",
        "libxml/c14n.h",
        "libxml/catalog.h",
        "libxml/debugXML.h",
        "libxml/xinclude.h",
        "libxml/xlink.h",
        "libxml/xmlmodule.h",
        "libxml/xmlautomata.h",
        "libxml/xmlunicode.h",
        "libxml/nanoftp.h",
        "libxml/nanohttp.h",
    ];
    
    for header in &public_headers {
        wrapper.push_str(&format!("#include \"{}\"\n", header));
    }
    
    wrapper.push_str("\n#endif /* LIBXML2_WRAPPER_H */\n");
    
    fs::write("wrapper.h", wrapper)?;
    println!("cargo:rerun-if-changed=wrapper.h");
    
    Ok(())
}

fn build_c_library(rust_modules: &[String]) -> Result<(), Box<dyn std::error::Error>> {
    let mut build = cc::Build::new();
    
    // Create mapping of C files to modules for exclusion
    let mut excluded_files = std::collections::HashSet::new();
    for module in rust_modules {
        if let Some((_, files)) = MODULE_FILES.iter().find(|(name, _)| *name == module) {
            for file in *files {
                excluded_files.insert(*file);
            }
        }
    }
    
    // Add include directories first
    for dir in INCLUDE_DIRS {
        build.include(dir);
    }
    
    // Add our compatibility header directory
    build.include(".");
    
    // Add private headers last to avoid conflicts with system headers
    build.include("../include/private");
    
    // Configure build with proper defines from CMake config
    configure_build_defines(&mut build);
    
    // For now, let's just try building one simple file to test
    let test_file = "../chvalid.c";
    if std::path::Path::new(test_file).exists() {
        build.file(test_file);
        println!("cargo:rerun-if-changed={}", test_file);
    }
    
    // TODO: Re-enable all files once we get the basic build working
    // Add module files that aren't excluded
    // for (_, files) in MODULE_FILES {
    //     for file in *files {
    //         if !excluded_files.contains(file) && file.ends_with(".c") {
    //             let full_path = format!("{}/{}", C_SOURCE_DIR, file);
    //             if std::path::Path::new(&full_path).exists() {
    //                 build.file(&full_path);
    //                 println!("cargo:rerun-if-changed={}", full_path);
    //             }
    //         }
    //     }
    // }
    
    // Add additional C files
    // for file in ADDITIONAL_C_FILES {
    //     let full_path = format!("{}/{}", C_SOURCE_DIR, file);
    //     if std::path::Path::new(&full_path).exists() {
    //         build.file(&full_path);
    //         println!("cargo:rerun-if-changed={}", full_path);
    //     }
    // }
    
    build.compile("libxml2_c");
    
    Ok(())
}

fn configure_build_defines(build: &mut cc::Build) {
    // Basic compilation flags
    build.flag("-Wno-unused-function");
    build.flag("-DLIBXML_STATIC");
    
    // Platform-specific base defines
    if cfg!(target_os = "windows") {
        build.define("WIN32", None);
        build.define("_WINDOWS", None);
    } else {
        // Enable config.h which contains all the feature detection
        build.define("HAVE_CONFIG_H", None);
        build.define("_GNU_SOURCE", None);
        build.define("_DEFAULT_SOURCE", None);
    }
    
    // Note: LIBXML_MODULE_EXTENSION is now defined in xmlversion.h, no need to duplicate
}

fn generate_bindings() -> Result<(), Box<dyn std::error::Error>> {
    let bindings = bindgen::Builder::default()
        .header("wrapper.h")
        .parse_callbacks(Box::new(bindgen::CargoCallbacks::default()))
        // Only include libxml2-specific items
        .allowlist_type(".*xml.*")
        .allowlist_type(".*HTML.*") 
        .allowlist_type(".*LIBXML_.*")
        .allowlist_function(".*xml.*")
        .allowlist_function(".*HTML.*")
        .allowlist_var(".*xml.*")
        .allowlist_var(".*LIBXML_.*")
        // Generate bindings for inline functions
        .generate_inline_functions(true)
        // Derive useful traits
        .derive_default(true)
        .derive_debug(true)
        // Handle common C patterns
        .size_t_is_usize(true)
        .generate()?;

    let out_path = PathBuf::from(env::var("OUT_DIR")?);
    bindings.write_to_file(out_path.join("bindings.rs"))?;
    
    Ok(())
}

fn setup_linking() {
    // Link our compiled C library
    println!("cargo:rustc-link-lib=static=libxml2_c");
    
    // Platform-specific system libraries
    if cfg!(target_os = "windows") {
        println!("cargo:rustc-link-lib=ws2_32");
        println!("cargo:rustc-link-lib=bcrypt");
    } else {
        println!("cargo:rustc-link-lib=m");
        if cfg!(target_os = "linux") {
            println!("cargo:rustc-link-lib=dl");
        }
    }
}