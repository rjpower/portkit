# Chimera Build System - Initial Project Setup

Create the foundational Rust project structure and build system for incremental C-to-Rust migration.

## Overview

The chimera build system allows a C project to be incrementally migrated to Rust by:
1. Building a mixed C/Rust library where modules can be swapped at compile time
2. Using bindgen to generate FFI bindings for the C portions
3. Allowing Rust implementations to override C symbols when enabled
4. Supporting differential testing between C and Rust implementations

The system works by:
- Compiling only the C modules that aren't being replaced by Rust
- Generating bindings only for the active C code
- Using Cargo features to control which Rust modules are compiled
- Using environment variables for runtime module selection

## Goal & Expected Output

You will produce a _stub project_ which contains the basic build setup for a Chimera project.
You will generate _empty_ implementations for each module & test, just sufficient to ensure the project builds.

## Input Project Structure

Project name: libxml2

{{include:sourcemap.txt}}
{{include:module_analysis/*.yaml}}

## Module Summaries

Read each of the module summaries in @module_summaries/ to learn about the expected module layout.


## Required Outputs

### 1. Complete Project Structure
```
rust/
├── Cargo.toml              # Main project configuration
├── build.rs                # Build script that orchestrates C/Rust compilation
├── wrapper.h               # Generated by build.rs - includes only active C headers
├── src/
│   ├── lib.rs             # Re-exports bindings and Rust modules
│   └── {module}/          # One directory per module 
│       └── mod.rs
├── fuzz/                  # Differential fuzz tests 
│   └── fuzz_{module}.rs
├── tests/
│   ├── abi_compat.rs      # Verify ABI compatibility 
│   └── {module}_test.rs   # Per-module tests 
├── c_src/                 # Original C source
```

### 2. `Cargo.toml` (Complete File)

```toml
[package]
name = "{project_name}"
version = "0.1.0"
edition = "2021"
authors = ["Your Name <you@example.com>"]
description = "Rust port of {project_name}"

[lib]
name = "{project_name}"
crate-type = ["staticlib", "rlib", "cdylib"]

[features]
default = []

# Expand this section, you'll have a Rust module feature for each module ported.
{for module in modules}
rust-{module} = []
{endfor}

# Convenience features
all-rust = [{comma_separated_rust_features}]

[dependencies]
libc = "0.2"

[build-dependencies]
cc = "1.1"
bindgen = "0.69"
glob = "0.3"

[dev-dependencies]
libfuzzer-sys = "0.4"
criterion = "0.5"

[profile.release]
lto = true

[profile.dev]
debug = true
```

### 3. `build.rs` 

```rust
use std::env;
use std::fs;
use std::path::{Path, PathBuf};

const C_SOURCE_DIR: &str = "{c_source_dir}";
const INCLUDE_DIRS: &[&str] = &{include_dirs_array};
const ALL_MODULES: &[&str] = &{modules_array};

fn main() {
    println!("cargo:rerun-if-changed=build.rs");
    println!("cargo:rerun-if-env-changed=RUST_MODULES");
    
    // Step 1: Determine which modules are implemented in Rust
    let rust_modules = get_rust_modules();
    
    // Step 2: Generate wrapper.h with only C module headers
    generate_wrapper_header(&rust_modules);
    
    // Step 3: Build C library excluding Rust modules
    build_c_library(&rust_modules);
    
    // Step 4: Generate bindings from wrapper.h
    generate_bindings();
    
    // Step 5: Set up linking
    setup_linking();
}

fn get_rust_modules() -> Vec<String> {
    // First check environment variable
    if let Ok(modules) = env::var("RUST_MODULES") {
        modules.split(',')
            .map(|s| s.trim().to_string())
            .filter(|m| ALL_MODULES.contains(&m.as_str()))
            .collect()
    } else {
        // Fall back to checking which features are enabled
        ALL_MODULES.iter()
            .filter(|&&module| {
                env::var(format!("CARGO_FEATURE_RUST_{}", module.to_uppercase()))
                    .is_ok()
            })
            .map(|&s| s.to_string())
            .collect()
    }
}

fn generate_wrapper_header(rust_modules: &[String]) {
    let mut wrapper = String::from("#ifndef {project_name}_H\n#define {project_name}_H\n\n");
    
    // Include headers for modules NOT implemented in Rust
    for module in ALL_MODULES {
        if !rust_modules.contains(&module.to_string()) {
            // This is simplified - in reality you'd map module names to header files
            wrapper.push_str(&format!("#include \"{}.h\"\n", module));
        }
    }
    
    wrapper.push_str("\n#endif /* {project_name}_H */\n");
    fs::write("wrapper.h", wrapper).expect("Failed to write wrapper.h");
    
    println!("cargo:rerun-if-changed=wrapper.h");
}

fn build_c_library(excluded_modules: &[String]) {
    let mut build = cc::Build::new();
    
    // Add all C files except those from excluded modules
    for entry in glob::glob(&format!("{}/*.c", C_SOURCE_DIR)).unwrap() {
        if let Ok(path) = entry {
            let filename = path.file_stem().unwrap().to_str().unwrap();
            
            // Skip if this file belongs to an excluded module
            if !excluded_modules.iter().any(|module| filename.contains(module)) {
                build.file(path);
            }
        }
    }
    
    // Add include directories
    for dir in INCLUDE_DIRS {
        build.include(dir);
    }
    
    // Platform-specific settings
    if cfg!(target_os = "windows") {
        build.define("WIN32", None);
    }
    
    build.compile("{project_name}_c");
}

fn generate_bindings() {
    let bindings = bindgen::Builder::default()
        .header("wrapper.h")
        .parse_callbacks(Box::new(bindgen::CargoCallbacks::default()))
        // Include all type definitions
        .allowlist_type(".*")
        .allowlist_function(".*")
        .allowlist_var(".*")
        // Generate bindings for inline functions
        .generate_inline_functions(true)
        // Derive useful traits
        .derive_default(true)
        .derive_debug(true)
        // Handle common C patterns
        .size_t_is_usize(true)
        .generate()
        .expect("Unable to generate bindings");

    let out_path = PathBuf::from(env::var("OUT_DIR").unwrap());
    bindings
        .write_to_file(out_path.join("bindings.rs"))
        .expect("Couldn't write bindings!");
}

fn setup_linking() {
    // Link our compiled C library
    println!("cargo:rustc-link-lib=static={project_name}_c");
    
    // Platform-specific system libraries
    if cfg!(target_os = "windows") {
        println!("cargo:rustc-link-lib=ws2_32");
        println!("cargo:rustc-link-lib=bcrypt");
    } else {
        println!("cargo:rustc-link-lib=m");
        if cfg!(target_os = "linux") {
            println!("cargo:rustc-link-lib=dl");
        }
    }
}
```

### 4. `src/lib.rs` (Complete File)

```rust
//! Chimera build of {project_name} - mixed C/Rust implementation
//! 
//! This library provides a gradual migration path from C to Rust.
//! Modules can be implemented in either C or Rust, controlled by feature flags.

#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(improper_ctypes)]

// Bindgen-generated FFI bindings
pub mod bindings {
    include!(concat!(env!("OUT_DIR"), "/bindings.rs"));
}

// Re-export all bindings by default
// Rust implementations will override these when their features are enabled
pub use bindings::*;

// Conditionally include Rust implementations
{for module in modules}
#[cfg(feature = "rust-{module}")]
pub mod {module};

#[cfg(feature = "rust-{module}")]
pub use {module}::*;
{endfor}

// Initialization function if needed
pub fn init_chimera() {
    // Any global initialization required
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_bindings_available() {
        // Verify bindings were generated successfully
        // This will be expanded by module-specific tests
    }
}
```

### 6. `test_migration.sh` (Helper Script)

```bash
#!/bin/bash
set -e

echo "Testing {project_name} chimera build configurations..."

# Test pure C build
echo "Testing pure C build..."
cargo clean
cargo test

# Test individual Rust modules
{for module in modules}
echo "Testing with rust-{module}..."
cargo clean
RUST_MODULES={module} cargo test
{endfor}

# Test all Rust
echo "Testing all Rust modules..."
cargo clean
cargo test --all-features

echo "All configurations tested successfully!"
```

## Invariants That Must Hold

After running this prompt, the following invariants MUST be satisfied:

1. **Build Invariants**:
   - `cargo build` succeeds with no features (pure C build)
   - `cargo build --features rust-{module}` succeeds for each module
   - `cargo build --all-features` succeeds (all Rust build)
   - `RUST_MODULES={module} cargo build` succeeds for each module

2. **Symbol Invariants**:
   - No duplicate symbols when linking
   - Rust functions override C functions when enabled
   - All C functions are available when Rust module is disabled

3. **Bindgen Invariants**:
   - `wrapper.h` only includes headers for non-Rust modules
   - Bindings are generated for all C types and functions
   - No bindgen errors or warnings

4. **Testing Invariants**:
   - `cargo test` passes with any feature combination
   - Fuzz targets compile when their required features are enabled
   - Examples compile and run successfully

## Validation

To verify the setup is correct:

```bash
# Should all succeed
cargo check
cargo check --features rust-dict
cargo check --all-features
RUST_MODULES=dict,list cargo check

# Should generate wrapper.h
cargo clean && cargo build
test -f wrapper.h

# Should show no undefined symbols
nm target/debug/lib{project_name}_chimera.a | grep -E "(dict|list)" | head -20
```

Generate ALL files listed above with the template values filled in based on the input configuration.